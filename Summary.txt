// index 를 가져 오는 거를 Objective-C의 NSArray를 통해서
var bookList = [Book]()
let index = (bookList as NSArray).index(of: book)

IB : Interface builder

@IBAction
@IBOutlet

// 반드시 맨 뒤에 '!'를 붙여준다 !! (어짜피 자동으로 되긴함)
@IBOutlet var resultTextView:UITextView!


UITextView : Scrollable, multiline text region.
UITextField
UILabel

App Programming Guide for iOS

기본적인 패턴 3개
1. MVC Pattern
Model View Controller

2. Target Action Pattern
3. Delegate Pattern

Concepts in Objective-C Programming
Foundation
(The Foundation Framework, google)

UIKit




UIImageView:
A UIImageView object displays a single image or a sequence of animated images in your interface.
보통 PNG를 쓰는게 좋다.

@IBOutlet var imgView:UIImageView!

animationImages:
An array of UIImage objects to use for an animation.

init?(named: String)
Returns the image object associated with the specified filename.

let cuteImages = [UIImage(named:"1.jpg")!]

animationDuration:
The amount of time it takes to go through one cycle of the images.
var animationDuration: TimeInterval { get set }

startAnimating():
Starts animating the images in the receiver.


UIButton:
Sets the title to use for the specified state.
setTitle(_:for:)

UISlider
A visual control used to select a single value from a continuous range of values.

yourUILabel.text = String.localizedStringWithFormat("%.2f %@", value, unit)


Protocol : Java의 interface와 같은 것
그러나 required를 붙이지 않으면 optional한 것이다.
-> Delegate를 쓰기 위한 것

@@@@@@@@@@@@@@@@@@@@@@@@@@ Delegate 사용 순서 3개 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
delegate protocol 추가. func 사용. 연결하기!!

UITextFieldDelegate

becomeFirstResponder():
Showing and Hiding the Keyboard

textFieldShouldReturn(_:)
-> keyboard return on click

    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        textField.resignFirstResponder() // 인자로 넘어온 부분을 키보드가 내려가게 함
        return true
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        //nameTextField.delegate = self 		// 이것을 반드시 해줘야 한다 !! 아니면 IB에 가서 delegate을 그 View 에 연결
    }

    // 바탕 화면이 눌렸을 때 키보드가 올라가게 함.
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
    	// self는 view 자기 자신, view 객체의 함수
        self.view.endEditing(true)
    }

UIResponder
Responding to Touch Events

    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        print("touchesBegan")
    }
    
    override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
        print("touchesMoved")
    }
    
    override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {
        print("touchesEnded")
    }


TextField 에서 키보드 설정해주는 것이 중요!!
Keyboard, clearbutton(textFieldShouldClear), return key, placeholder





in AppDelegate.swift

	// 올해 새로 생긴 것. 아직 별로 쓸모가..
    func application(_ application: UIApplication, willFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -> Bool {
        print("willFinishLaunchingWithOptions")
        return true
    }

    // window 위에 view 들이 붙는 구조, DB 초기화하는 부분(Core data), 앱 처음 시작시 한번 만
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        print("didFinishLaunchingWithOptions")
        return true
    }



    // 활성화 되면 실행 되는 부분, Background -> Foreground 할 때 에도 실행된다.
    // 전화가 우선순위가 가장 높다. 게임을 하다가 전화가 오고, 다시 게임으로 넘어갈 때
    func applicationDidBecomeActive(_ application: UIApplication) {
        // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
        print("applicationDidBecomeActive")
    }

// 처음 실행시
willFinishLaunchingWithOptions
didFinishLaunchingWithOptions
applicationDidBecomeActive

// background 진입 // 여기 있어도 Resources 를 잡고 있는 상태임
applicationWillResignActive // 메시지가 온다면 이 함수만 뜬다. 취소를 누르면 밑에꺼는 실행 안됨
applicationDidEnterBackground // Resources 해제!!

// Foreground 진입
applicationWillEnterForeground // 게임 같은 경우 Resources를 release! loading..
applicationDidBecomeActive

// App 종료시
applicationWillTerminate


UIViewController

in ViewController.swift

    override func loadView() { // 하드 코딩으로 View 를 만들 때 사용 하는 함수임.
    						   // Your custom implementation of this method should not call super.
        super.loadView()
        print("loadView")
    }

    override func viewDidLoad() { // Called after the controller's view is loaded into memory. 초기화!!
        super.viewDidLoad()
        print("viewDidLoad")
    }
    
    override func viewWillAppear(_ animated: Bool) { // 확인해서 수정해야 하는 작업을 여기서 !!
        super.viewWillAppear(true)
        print("viewWillAppear")
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(true)
        print("viewDidAppear")
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(true)
        print("viewWillDisappear")
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(true)
        print("viewDidDisappear")
    }

willFinishLaunchingWithOptions
didFinishLaunchingWithOptions
loadView
viewDidLoad
viewWillAppear
applicationDidBecomeActive
viewDidAppear

// View 부를 때
loadView
viewDidLoad
viewWillAppear
viewDidAppear

// 다른 View로 넘어 갈 때
viewWillDisappear
viewDidDisappear

Segue:
Segue도 하나의 객체임. Identifier도 정할 수 있고, Transition을 통해서 넘어가는 화면 애니메이션 설정 가능

Button 과 View 를 연결하면서 present modally!




UISegmentedControl:
A UISegmentedControl object is a horizontal control made of multiple segments, each segment functioning as a discrete button.
selectedSegmentIndex
titleForSegment(at:)


tool bar 안에 Bar button item(System item으로 아이콘 설정 가능)
-> 맨 처음에 왼쪽 정렬이니깐 Flexible space bar button item을 사이사이에 넣어서 해결(<-> Fixed Space bar button item)


UIWebView:
You can use the UIWebView class to embed web content in your app

loadRequest(_:) // 비동기이므로, 다른 쓰레드가 돌게 되는 것임.
Connects to a given URL by initiating an asynchronous client request.

NSURL:
An NSURL object represents a URL that can potentially contain the location of a resource on a remote server, the path of a local file on disk, or even an arbitrary piece of encoded data.



    @IBOutlet weak var mainWebView: UIWebView!

    let urlString = "https://www.facebook.com"
    mainWebView.loadRequest(URLRequest(url: URL(string: urlString)!)) // unWrapping!!!


unwrapping 에 문제가 생기는 부분이있으면, 그 해당 return 값을 쓰는 부분에 !를 붙인다.

    @IBAction func bookMarkAction(_ sender: Any) {
        let bookMarkUrl = bookMarkSegmentedControl.titleForSegment(at: bookMarkSegmentedControl.selectedSegmentIndex)
        let urlString = "https://www.\(bookMarkUrl!).com"
        mainWebView.loadRequest(URLRequest(url: URL(string: urlString)!))
        urlTextField.text = urlString
    }


UIActivityIndicatorView:
Use an activity indicator to show that a task is in progress. An activity indicator appears as a “gear” that is either spinning or stopped

startAnimating()
stopAnimating() // 비동기에 대한 처리 때문에 두 함수의 위치가 중요함

UIWebViewDelegate
webViewDidStartLoad(_:)
webViewDidFinishLoad(_:)
-> Hides when Stopped 

WebView에 이미 Action이 있으므로, goBack, forward, stop, reload 연결만 해주면 됨

회원 가입시에는 WebView가 거의 필요함. 공지사항 or Event // Webkit engine !!! 매우 중요



Switch

isHidden (in UIView) t/f !!

sender
print((sender as AnyObject).description!) // sender가 누군지 확인하는법

returnDateLabel.isHidden = !(sender as! UISwitch).isOn

IB 에서 View Controller를 반드시 누른 후에 !! 여러가지 액션에 관한 설정


UIDatePicker:
A UIDatePicker object is a control used for the inputting of date and time values
Value changed로 함수 생성 -> 날짜가 바뀔 때 마다, label 값을 바꿔주도록 한다.

같은 이벤트에 대해서는 Tag를 통해서 구분할 수 있다.
    
    var buttonTag:Int = 1

    buttonTag = (sender as! UIButton).tag


    @IBAction func selectedDateAction(_ sender: Any) {

    	// Date -> String 변환 하는 법 !!

        let formatter = DateFormatter()
        formatter.dateFormat = "YY-MM-d hh:mma"
        let dateString = formatter.string(from: (sender as! UIDatePicker).date)

        if(buttonTag == 1) {
            departureDateButton.setTitle(dateString, for: UIControlState())
        } else {
            returnDateButton.setTitle(dateString, for: UIControlState())
        }
    }



@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ UI Picker View @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

UIPickerView:
The UIPickerView class implements objects, called picker views, that use a spinning-wheel or slot-machine metaphor to show one or more sets of values. Users select values by rotating the wheels so that the desired row of values aligns with a selection indicator.

 -> Action을 모두 Delegate로 처리한다. Action이 따로 존재하지않음
Additionally, picker views require a data source !!

The data source adopts the @@@@ UIPickerViewDataSource @@@@ protocol and implements the required methods to return the number of components (columns) and the number of rows in each component. Note that the actual contents of each row comes from the delegate, not the data source.

the number of rows !! 몇개 만들 건지 준비만 해라

numberOfComponents -> Required method : // 몇개 Column을 만들 꺼니? 개수를 반환
Called by the picker view when it needs the number of components.

pickerView -> Required method : // 배열을 미리 만들자
Called by the picker view when it needs the number of rows for a specified component.
func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int



// 둘중 하나는 무조건 구현해라
The methods in this group are marked @optional. 
However, to use a picker view, you must implement either 
the pickerView(_:titleForRow:forComponent:) or 
the pickerView(_:viewForRow:forComponent:reusing:) method 
to provide the content of component rows.


pickerView(_:titleForRow:forComponent:)
Called by the picker view when it needs the title to use for a given row in a given component.

optional func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -> String?
Called by the picker view when it needs the title to use for a given row in a given component.
// Picker view 안에 Text(Title)을 넣을 때 사용

optional func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -> UIView
// Picker view 안에 ImageView를 넣을 때 사용



optional func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int)
Called by the picker view when the user selects a row in a component.
    // Picker view 의 값이 바뀔 때마다 호출 되는 함수
    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {
        print("didSelectRow row:\(row), component:\(component)")
    }


1. 가장 먼저 protocol 선언
UIPickerViewDataSource, UIPickerViewDelegate

2.Required method 선언해주자(pickerView, numberOfComponents)

3. UIPickerView 의 delegate를 View에 연결


// 함수 호출 순서

가장 먼저 numberOfComponents 함수를 통해 몇개 만들건지 호출

그 다음 func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -> Int 함수를 통해서
각 Column들의 조건을 확인해서 몇개인지 체크

그 다음 func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -> String? 함수를 통해서
text 값들이 들어가게 됨

    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {
        if component == 0 {
            if row == 0 {
                carModel = tesla
            } else if row == 1 {
                carModel = lamborghini
            } else {
                carModel = porsche
            }
        }
        
        // 값은 바뀌었으나, 다시 Refresh를 해줘야 한다.
        pickerView.reloadAllComponents()
    }

func selectedRow(inComponent component: Int) -> Int
Returns the index of the selected row in a given component. // 현재 선택 된 Row 의 값들

imgView.image = UIImage(named: carModelImage[pickerView.selectedRow(inComponent: 1)])

// Image View 꾸미는 부분
imgView.layer.cornerRadius = 50.0
imgView.layer.masksToBounds = true



Tab bar
is inital view controller?

오른쪽으로 새로운 view 에 연결해서 Relationship segue!!

tab bar인 경우에는 5개를 넘어가면 more를 통해서 navigation controller가 실행된다. -> 순서를 Edit 할 수 있게 됨

해당 View의 파일을 만들 때 에는 Cocoa touch class로 생성해서, UIViewController 설정을 해줘라

그리고 IB에서 @@@@ Indentity inspector @@@@ (3번째 tab)에서 class를 연결해줌!! 매우중요






UI Table view:
An instance of UITableView (or simply, a table view) is a means for displaying and editing hierarchical lists of information.

The data source must adopt the UITableViewDataSource protocol and the delegate must adopt the UITableViewDelegate protocol.

numberOfSections // default section 1

하나의 아이템들은 하나의 Cell로 구성

func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell
Required!
Asks the data source for a cell to insert in a particular location of the table view.

func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int
Required!
Tells the data source to return the number of rows in a given section of a table view.



UITableViewDataSource protocol 추가

	// 맨처음에 이 함수를 호출 해서 몇개의 Cell을 만들 건지 알려줌
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return datalist.count
    } 
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "Cell", for: indexPath)
        
        /* 하드코딩 방식, 셀이 없으니까 만들어줘야지.
           화면에 보이는 만큼만 Cell을 만들고, Scroll을 내리면 queue에 하나를 빼고, 하나를 넣는다. 이 때에도 이 함수가 호출 됨.

        if cell == nil {
            cell = UITableViewCell(style: UITableViewCellStyle.subtitle, reuseIdentifier: "Cell")
        }
        */
        
        // print("indexPath row : \(indexPath.row)")
        // 계속 cell마다 이 함수가 호출 되면서 생성된다
        
        var currentDic = datalist[indexPath.row]
        cell.textLabel!.text = currentDic["지역"]
        cell.detailTextLabel!.text = currentDic["날씨"]
        
        return cell
    }


var datalist:[[String: String]] = [] // List 안의 Dictionary !!! 매우 중요

IndexPath // 구조체!!
IndexPath represents the path to a specific node in a tree of nested array collections.
row, section 속성을 사용한다

delegate 연결해주고

Cell 의 Style 선택, 지금은 Subtitle로 해서, detailTextLabel 사용

@@@@@@@@@@@@@ 매우 중요 @@@@@@@@@@@@@@@@@
identifier 설정!! 이것과 UITableViewCell return 하는 tableView 함수의 인자와 똑같이!!
let cell = tableView.dequeueReusableCell(withIdentifier: "Cell", for: indexPath)















